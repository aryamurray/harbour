//! Interop file generation.
//!
//! Generates pkg-config files, CMake package configs, and surface.json
//! for non-Harbour consumers.

use std::path::{Path, PathBuf};

use anyhow::Result;
use serde::{Deserialize, Serialize};

use crate::builder::surface_resolver::{EffectiveCompileSurface, EffectiveLinkSurface};
use crate::core::Package;

/// Generate interop files for a built package.
pub fn generate_interop_files(
    package: &Package,
    target_name: &str,
    output_dir: &Path,
    compile_surface: &EffectiveCompileSurface,
    link_surface: &EffectiveLinkSurface,
) -> Result<()> {
    // Generate pkg-config file
    generate_pkg_config(package, target_name, output_dir, compile_surface, link_surface)?;

    // Generate CMake config files
    generate_cmake_config(package, target_name, output_dir, compile_surface, link_surface)?;

    // Generate surface.json
    generate_surface_json(package, target_name, output_dir, compile_surface, link_surface)?;

    Ok(())
}

/// Generate a pkg-config .pc file.
fn generate_pkg_config(
    package: &Package,
    target_name: &str,
    output_dir: &Path,
    compile_surface: &EffectiveCompileSurface,
    link_surface: &EffectiveLinkSurface,
) -> Result<()> {
    let lib_dir = output_dir.join("lib");
    let _include_dir = output_dir.join("include");

    // Build Cflags
    let mut cflags = Vec::new();
    for dir in &compile_surface.include_dirs {
        cflags.push(format!("-I{}", dir.display()));
    }
    for define in &compile_surface.defines {
        cflags.push(define.to_flag());
    }

    // Build Libs
    let mut libs = vec![format!("-L{}", lib_dir.display())];
    libs.push(format!("-l{}", target_name));

    for lib in &link_surface.libs {
        libs.extend(lib.to_flags());
    }

    let pc_content = format!(
        r#"prefix={prefix}
libdir=${{prefix}}/lib
includedir=${{prefix}}/include

Name: {name}
Description: {description}
Version: {version}
Cflags: {cflags}
Libs: {libs}
"#,
        prefix = output_dir.display(),
        name = target_name,
        description = package
            .manifest()
            .package
            .as_ref()
            .and_then(|p| p.description.as_deref())
            .unwrap_or(""),
        version = package.version(),
        cflags = cflags.join(" "),
        libs = libs.join(" ")
    );

    let pc_path = output_dir.join(format!("{}.pc", target_name));
    std::fs::write(&pc_path, pc_content)?;

    tracing::debug!("Generated {}", pc_path.display());

    Ok(())
}

/// Generate CMake package config files.
fn generate_cmake_config(
    package: &Package,
    target_name: &str,
    output_dir: &Path,
    compile_surface: &EffectiveCompileSurface,
    _link_surface: &EffectiveLinkSurface,
) -> Result<()> {
    let cmake_dir = output_dir.join("cmake");
    std::fs::create_dir_all(&cmake_dir)?;

    // Generate <name>Config.cmake
    let config_content = format!(
        r#"# Generated by Harbour
@PACKAGE_INIT@

include("${{CMAKE_CURRENT_LIST_DIR}}/{target_name}Targets.cmake")

check_required_components({target_name})
"#
    );

    std::fs::write(
        cmake_dir.join(format!("{}Config.cmake", target_name)),
        config_content,
    )?;

    // Generate <name>Targets.cmake
    let lib_file = format!("lib{}.a", target_name); // Adjust for platform
    let include_dirs: Vec<String> = compile_surface
        .include_dirs
        .iter()
        .map(|p| p.display().to_string())
        .collect();

    let targets_content = format!(
        r#"# Generated by Harbour

add_library({target_name}::lib STATIC IMPORTED)

set_target_properties({target_name}::lib PROPERTIES
    IMPORTED_LOCATION "${{CMAKE_CURRENT_LIST_DIR}}/../lib/{lib_file}"
    INTERFACE_INCLUDE_DIRECTORIES "{include_dirs}"
)
"#,
        target_name = target_name,
        lib_file = lib_file,
        include_dirs = include_dirs.join(";")
    );

    std::fs::write(
        cmake_dir.join(format!("{}Targets.cmake", target_name)),
        targets_content,
    )?;

    // Generate <name>ConfigVersion.cmake
    let version = package.version();
    let version_content = format!(
        r#"# Generated by Harbour
set(PACKAGE_VERSION "{version}")

if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
    set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
    set(PACKAGE_VERSION_COMPATIBLE TRUE)
    if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
        set(PACKAGE_VERSION_EXACT TRUE)
    endif()
endif()
"#
    );

    std::fs::write(
        cmake_dir.join(format!("{}ConfigVersion.cmake", target_name)),
        version_content,
    )?;

    tracing::debug!("Generated CMake config in {}", cmake_dir.display());

    Ok(())
}

/// Machine-readable surface contract.
#[derive(Debug, Serialize, Deserialize)]
pub struct SurfaceJson {
    /// Package name
    pub name: String,
    /// Package version
    pub version: String,
    /// Compile surface
    pub compile: SurfaceJsonCompile,
    /// Link surface
    pub link: SurfaceJsonLink,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SurfaceJsonCompile {
    pub include_dirs: Vec<PathBuf>,
    pub defines: Vec<String>,
    pub cflags: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SurfaceJsonLink {
    pub lib_dirs: Vec<PathBuf>,
    pub libs: Vec<String>,
    pub ldflags: Vec<String>,
    pub frameworks: Vec<String>,
}

/// Generate surface.json for machine consumption.
fn generate_surface_json(
    package: &Package,
    target_name: &str,
    output_dir: &Path,
    compile_surface: &EffectiveCompileSurface,
    link_surface: &EffectiveLinkSurface,
) -> Result<()> {
    let surface = SurfaceJson {
        name: target_name.to_string(),
        version: package.version().to_string(),
        compile: SurfaceJsonCompile {
            include_dirs: compile_surface.include_dirs.clone(),
            defines: compile_surface.defines.iter().map(|d| d.to_flag()).collect(),
            cflags: compile_surface.cflags.clone(),
        },
        link: SurfaceJsonLink {
            lib_dirs: link_surface.lib_dirs.clone(),
            libs: link_surface
                .libs
                .iter()
                .flat_map(|l| l.to_flags())
                .collect(),
            ldflags: link_surface.ldflags.clone(),
            frameworks: link_surface.frameworks.clone(),
        },
    };

    let json = serde_json::to_string_pretty(&surface)?;
    let path = output_dir.join("surface.json");
    std::fs::write(&path, json)?;

    tracing::debug!("Generated {}", path.display());

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_surface_json_serialization() {
        let surface = SurfaceJson {
            name: "mylib".to_string(),
            version: "1.0.0".to_string(),
            compile: SurfaceJsonCompile {
                include_dirs: vec![PathBuf::from("/usr/include")],
                defines: vec!["-DFOO".to_string()],
                cflags: vec!["-Wall".to_string()],
            },
            link: SurfaceJsonLink {
                lib_dirs: vec![PathBuf::from("/usr/lib")],
                libs: vec!["-lpthread".to_string()],
                ldflags: vec![],
                frameworks: vec![],
            },
        };

        let json = serde_json::to_string(&surface).unwrap();
        assert!(json.contains("mylib"));
        assert!(json.contains("1.0.0"));
    }
}
