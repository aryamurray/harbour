//! TypeScript/koffi binding generator.
//!
//! Generates TypeScript bindings that use the koffi library for FFI.

use std::io::Write;
use std::path::Path;

use anyhow::{Context, Result};

use super::types::{CEnum, CFunction, CStruct, CType, CallingConvention, ParsedHeader};
use crate::core::target::FfiBundler;

/// TypeScript binding generator.
pub struct TypeScriptGenerator {
    /// Library name
    library_name: String,
    /// Generate async wrappers
    async_wrappers: bool,
    /// FFI bundler to use
    bundler: FfiBundler,
    /// Library file path (relative to output)
    lib_path: String,
}

impl TypeScriptGenerator {
    /// Create a new TypeScript generator.
    pub fn new(library_name: impl Into<String>) -> Self {
        TypeScriptGenerator {
            library_name: library_name.into(),
            async_wrappers: false,
            bundler: FfiBundler::Koffi,
            lib_path: String::new(),
        }
    }

    /// Set async wrapper generation.
    pub fn with_async_wrappers(mut self, async_wrappers: bool) -> Self {
        self.async_wrappers = async_wrappers;
        self
    }

    /// Set the FFI bundler.
    pub fn with_bundler(mut self, bundler: FfiBundler) -> Self {
        self.bundler = bundler;
        self
    }

    /// Set the library path.
    pub fn with_lib_path(mut self, path: impl Into<String>) -> Self {
        self.lib_path = path.into();
        self
    }

    /// Generate TypeScript bindings from parsed headers.
    pub fn generate(&self, header: &ParsedHeader) -> Result<String> {
        let mut output = String::new();

        // File header
        output.push_str(&self.generate_header());

        // Imports
        output.push_str(&self.generate_imports());

        // Library loader
        output.push_str(&self.generate_loader());

        // Enums as TypeScript enums
        for enum_def in &header.enums {
            output.push_str(&self.generate_enum(enum_def));
        }

        // Structs as koffi struct definitions
        for struct_def in &header.structs {
            output.push_str(&self.generate_struct(struct_def));
        }

        // Struct interfaces for type safety
        for struct_def in &header.structs {
            output.push_str(&self.generate_struct_interface(struct_def));
        }

        // Function bindings
        output.push_str(&self.generate_function_section(&header.functions));

        // Export all
        output.push_str(&self.generate_exports(header));

        Ok(output)
    }

    /// Generate to a file.
    pub fn generate_to_file(&self, header: &ParsedHeader, path: &Path) -> Result<()> {
        let content = self.generate(header)?;

        // Create parent directories
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)
                .with_context(|| format!("failed to create directory: {}", parent.display()))?;
        }

        let mut file = std::fs::File::create(path)
            .with_context(|| format!("failed to create file: {}", path.display()))?;

        file.write_all(content.as_bytes())
            .with_context(|| format!("failed to write to file: {}", path.display()))?;

        Ok(())
    }

    /// Generate file header comment.
    fn generate_header(&self) -> String {
        format!(
            r#"/**
 * FFI bindings for {}
 *
 * Auto-generated by Harbour FFI binding generator.
 * Do not edit manually.
 *
 * @packageDocumentation
 */

"#,
            self.library_name
        )
    }

    /// Generate import statements.
    fn generate_imports(&self) -> String {
        match self.bundler {
            FfiBundler::Koffi => r#"import koffi from 'koffi';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

"#
            .to_string(),
            FfiBundler::FfiNapi => r#"import ffi from 'ffi-napi';
import ref from 'ref-napi';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

"#
            .to_string(),
            _ => String::new(),
        }
    }

    /// Generate library loader code.
    fn generate_loader(&self) -> String {
        let lib_path = if self.lib_path.is_empty() {
            format!("lib{}", self.library_name)
        } else {
            self.lib_path.clone()
        };

        match self.bundler {
            FfiBundler::Koffi => {
                format!(
                    r#"// Library path resolution
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Platform-specific library extension
const PLATFORM_EXT: Record<string, string> = {{
  'win32': '.dll',
  'darwin': '.dylib',
  'linux': '.so',
}};

const libExt = PLATFORM_EXT[process.platform] ?? '.so';
const libPath = join(__dirname, '{}' + libExt);

// Load the native library
const lib = koffi.load(libPath);

"#,
                    lib_path
                )
            }
            FfiBundler::FfiNapi => {
                format!(
                    r#"// Library path resolution
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Platform-specific library extension
const PLATFORM_EXT: Record<string, string> = {{
  'win32': '.dll',
  'darwin': '.dylib',
  'linux': '.so',
}};

const libExt = PLATFORM_EXT[process.platform] ?? '.so';
const libPath = join(__dirname, '{}' + libExt);

// Load the native library
const lib = ffi.Library(libPath, {{

"#,
                    lib_path
                )
            }
            _ => String::new(),
        }
    }

    /// Generate enum definition.
    fn generate_enum(&self, enum_def: &CEnum) -> String {
        let mut output = String::new();

        // Documentation
        if let Some(ref doc) = enum_def.doc {
            output.push_str(&format!("/** {} */\n", doc));
        }

        output.push_str(&format!("export enum {} {{\n", enum_def.name));

        let mut next_value = 0i64;
        for variant in &enum_def.variants {
            let value = variant.value.unwrap_or(next_value);
            output.push_str(&format!("  {} = {},\n", variant.name, value));
            next_value = value + 1;
        }

        output.push_str("}\n\n");
        output
    }

    /// Generate koffi struct definition.
    fn generate_struct(&self, struct_def: &CStruct) -> String {
        match self.bundler {
            FfiBundler::Koffi => self.generate_koffi_struct(struct_def),
            FfiBundler::FfiNapi => self.generate_ffi_napi_struct(struct_def),
            _ => String::new(),
        }
    }

    /// Generate koffi struct.
    fn generate_koffi_struct(&self, struct_def: &CStruct) -> String {
        let mut output = String::new();

        if let Some(ref doc) = struct_def.doc {
            output.push_str(&format!("/** {} */\n", doc));
        }

        output.push_str(&format!(
            "const {} = koffi.struct('{}', {{\n",
            struct_def.name, struct_def.name
        ));

        for field in &struct_def.fields {
            let koffi_type = field.field_type.as_koffi();
            output.push_str(&format!("  {}: '{}',\n", field.name, koffi_type));
        }

        output.push_str("});\n\n");
        output
    }

    /// Generate ffi-napi struct.
    fn generate_ffi_napi_struct(&self, struct_def: &CStruct) -> String {
        let mut output = String::new();

        if let Some(ref doc) = struct_def.doc {
            output.push_str(&format!("/** {} */\n", doc));
        }

        output.push_str(&format!(
            "const {} = ref.types.struct({{\n",
            struct_def.name
        ));

        for field in &struct_def.fields {
            let ffi_type = self.ctype_to_ffi_napi(&field.field_type);
            output.push_str(&format!("  {}: {},\n", field.name, ffi_type));
        }

        output.push_str("});\n\n");
        output
    }

    /// Generate TypeScript interface for struct.
    fn generate_struct_interface(&self, struct_def: &CStruct) -> String {
        let mut output = String::new();

        if let Some(ref doc) = struct_def.doc {
            output.push_str(&format!("/** {} */\n", doc));
        }

        output.push_str(&format!("export interface I{} {{\n", struct_def.name));

        for field in &struct_def.fields {
            let ts_type = field.field_type.as_typescript();
            output.push_str(&format!("  {}: {};\n", field.name, ts_type));
        }

        output.push_str("}\n\n");
        output
    }

    /// Generate function section.
    fn generate_function_section(&self, functions: &[CFunction]) -> String {
        match self.bundler {
            FfiBundler::Koffi => self.generate_koffi_functions(functions),
            FfiBundler::FfiNapi => self.generate_ffi_napi_functions(functions),
            _ => String::new(),
        }
    }

    /// Generate koffi function bindings.
    fn generate_koffi_functions(&self, functions: &[CFunction]) -> String {
        let mut output = String::new();

        output.push_str("// Function bindings\n");

        for func in functions {
            output.push_str(&self.generate_koffi_function(func));
        }

        output
    }

    /// Generate a single koffi function binding.
    fn generate_koffi_function(&self, func: &CFunction) -> String {
        let mut output = String::new();

        // Documentation
        if let Some(ref doc) = func.doc {
            output.push_str(&format!("/** {} */\n", doc));
        } else {
            // Generate JSDoc from signature
            output.push_str("/**\n");
            for param in &func.params {
                if !param.name.is_empty() {
                    output.push_str(&format!(
                        " * @param {} - {}\n",
                        param.name,
                        param.param_type.as_typescript()
                    ));
                }
            }
            if !func.return_type.is_void() {
                output.push_str(&format!(
                    " * @returns {}\n",
                    func.return_type.as_typescript()
                ));
            }
            output.push_str(" */\n");
        }

        // Generate koffi prototype
        let return_type = func.return_type.as_koffi();
        let params: Vec<String> = func
            .params
            .iter()
            .map(|p| format!("'{}'", p.param_type.as_koffi()))
            .collect();

        let proto = if func.calling_convention != CallingConvention::Cdecl {
            format!(
                "koffi.proto('{}', '{}', [{}])",
                func.calling_convention.as_koffi(),
                return_type,
                params.join(", ")
            )
        } else {
            format!("'{}', [{}]", return_type, params.join(", "))
        };

        // Generate the function export
        let ts_params: Vec<String> = func
            .params
            .iter()
            .enumerate()
            .map(|(i, p)| {
                let name = if p.name.is_empty() {
                    format!("arg{}", i)
                } else {
                    p.name.clone()
                };
                format!("{}: {}", name, p.param_type.as_typescript())
            })
            .collect();

        let ts_return = func.return_type.as_typescript();

        output.push_str(&format!(
            "export const {} = lib.func('{}', {}) as ({}) => {};\n",
            func.name,
            func.name,
            proto,
            ts_params.join(", "),
            ts_return
        ));

        // Generate async wrapper if requested
        if self.async_wrappers && !func.return_type.is_void() {
            output.push_str(&format!(
                "\nexport const {}Async = lib.func('{}', {}).async as ({}) => Promise<{}>;\n",
                func.name,
                func.name,
                proto,
                ts_params.join(", "),
                ts_return
            ));
        }

        output.push('\n');
        output
    }

    /// Generate ffi-napi function bindings.
    fn generate_ffi_napi_functions(&self, functions: &[CFunction]) -> String {
        let mut output = String::new();

        for func in functions {
            let return_type = self.ctype_to_ffi_napi(&func.return_type);
            let params: Vec<String> = func
                .params
                .iter()
                .map(|p| self.ctype_to_ffi_napi(&p.param_type))
                .collect();

            output.push_str(&format!(
                "  '{}': [{}, [{}]],\n",
                func.name,
                return_type,
                params.join(", ")
            ));
        }

        output.push_str("});\n\n");

        // Generate typed exports
        output.push_str("// Typed function exports\n");
        for func in functions {
            let ts_params: Vec<String> = func
                .params
                .iter()
                .enumerate()
                .map(|(i, p)| {
                    let name = if p.name.is_empty() {
                        format!("arg{}", i)
                    } else {
                        p.name.clone()
                    };
                    format!("{}: {}", name, p.param_type.as_typescript())
                })
                .collect();

            let ts_return = func.return_type.as_typescript();

            output.push_str(&format!(
                "export const {} = lib.{} as ({}) => {};\n",
                func.name,
                func.name,
                ts_params.join(", "),
                ts_return
            ));
        }

        output
    }

    /// Convert CType to ffi-napi type.
    fn ctype_to_ffi_napi(&self, ctype: &CType) -> String {
        match ctype {
            CType::Void => "ref.types.void".to_string(),
            CType::Int8 => "ref.types.int8".to_string(),
            CType::Int16 => "ref.types.int16".to_string(),
            CType::Int32 => "ref.types.int32".to_string(),
            CType::Int64 => "ref.types.int64".to_string(),
            CType::UInt8 => "ref.types.uint8".to_string(),
            CType::UInt16 => "ref.types.uint16".to_string(),
            CType::UInt32 => "ref.types.uint32".to_string(),
            CType::UInt64 => "ref.types.uint64".to_string(),
            CType::Float => "ref.types.float".to_string(),
            CType::Double => "ref.types.double".to_string(),
            CType::Bool => "ref.types.bool".to_string(),
            CType::Char => "ref.types.char".to_string(),
            CType::UChar => "ref.types.uchar".to_string(),
            CType::Pointer(inner) if matches!(**inner, CType::Char) => {
                "ref.types.CString".to_string()
            }
            CType::Pointer(_) | CType::ConstPointer(_) => "ref.refType(ref.types.void)".to_string(),
            CType::Struct(name) => name.clone(),
            CType::Enum(_) => "ref.types.int32".to_string(),
            _ => "ref.types.void".to_string(),
        }
    }

    /// Generate exports section.
    fn generate_exports(&self, header: &ParsedHeader) -> String {
        let mut output = String::new();

        output.push_str("\n// Re-export types\n");

        // Export struct types
        for s in &header.structs {
            output.push_str(&format!("export {{ {} }};\n", s.name));
        }

        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::builder::bindings::types::{CEnumVariant, CField, CParam};

    #[test]
    fn test_generate_enum() {
        let gen = TypeScriptGenerator::new("test");
        let enum_def = CEnum {
            name: "Color".to_string(),
            variants: vec![
                CEnumVariant {
                    name: "RED".to_string(),
                    value: Some(0),
                },
                CEnumVariant {
                    name: "GREEN".to_string(),
                    value: Some(1),
                },
            ],
            doc: None,
        };

        let output = gen.generate_enum(&enum_def);
        assert!(output.contains("export enum Color"));
        assert!(output.contains("RED = 0"));
        assert!(output.contains("GREEN = 1"));
    }

    #[test]
    fn test_generate_struct() {
        let gen = TypeScriptGenerator::new("test");
        let struct_def = CStruct {
            name: "Point".to_string(),
            fields: vec![
                CField {
                    name: "x".to_string(),
                    field_type: CType::Int32,
                    bit_width: None,
                },
                CField {
                    name: "y".to_string(),
                    field_type: CType::Int32,
                    bit_width: None,
                },
            ],
            packed: false,
            doc: None,
        };

        let output = gen.generate_struct(&struct_def);
        assert!(output.contains("koffi.struct('Point'"));
        assert!(output.contains("x: 'int32'"));
    }

    #[test]
    fn test_generate_function() {
        let gen = TypeScriptGenerator::new("test");
        let func = CFunction {
            name: "add".to_string(),
            return_type: CType::Int32,
            params: vec![
                CParam {
                    name: "a".to_string(),
                    param_type: CType::Int32,
                },
                CParam {
                    name: "b".to_string(),
                    param_type: CType::Int32,
                },
            ],
            calling_convention: CallingConvention::Cdecl,
            variadic: false,
            doc: None,
        };

        let output = gen.generate_koffi_function(&func);
        assert!(output.contains("export const add"));
        assert!(output.contains("lib.func('add'"));
    }
}
